Ιωάννης Καπετανγεώργης
Α.Μ.: 1115201800061

Προγραμματισμός Συστημάτων - Project 3
---------------------------------------

Γενικά σχόλια:
--------------
- Η υλοποίηση του πρώτου part της εργασίας περιέχεται στο directory με όνομα travelMonitor. 
- Όλα τα αρχεία κώδικα είναι σχολιασμένα πολύ αναλυτικά και εξηγείται η κάθε λειτουργία που γίνεται στο κάθε σημείο.
- Όση μνήμη έχει δεσμευθεί δυναμικά κατά την εκτέλεση του προγράμματος, αποδεσμεύεται πριν το τέλος αυτού με ελεγχόμενο τρόπο και χωρίς να υπάρχουν απώλειες μνήμης η errors. Έχει ελεγχθεί μέσω του valgrind.
- Ο κώδικας έχει χωριστεί σε πολλά αρχεία (.c και .h) ανάλογα με την λειτουργία που υλοποιούν έτσι ώστε να επιτευχθεί abstraction των δεδομένων αλλά και να είναι πιο κατανοητός και ευανάγνωστος ο συνολικός κώδικας. Επίσης επιτυγχάνεται πλήρης απόκρυψη πληροφορίας. Για κάθε αρχείο κώδικα (.c) (εκτός των αρχείου travelMonitorClient.c και monitorServer.c που περιέχουν τις main) υπάρχουν και τα αντίστοιχα header αρχεία, τα οποία περιέχουν τις απαραίτητες δηλώσεις έτσι ώστε να παρέχεται το "interface" σε ένα άλλο αρχείο το οποίο χρησιμοποιεί τις λειτουργίες αυτές.
- Σε όλα τα σημεία που αποθηκεύεται μια συμβολοσειρά, χρησιμοποιώ τον τύπο char * (και όχι κάποιον στατικό πίνακα χαρακτήρων π.χ. char [50]) έτσι ώστε να δεσμεύεται μόνο όσος χώρος χρειάζεται για την αποθήκευση της συμβολοσειράς. Εξαίρεση σε αυτό αποτελούν μόνο κάποιοι προσωρινοί buffers κατά το διάβασμα εντολών του χρήστη και εγγραφών του αρχείου.
- Έχει υλοποιηθεί το απαραίτητο error checking σχετικά με την εισαγωγή των δεδομένων (τόσο από το input αρχείο όσο και από της εντολές του χρήστη). Έχουν ληφθεί υπόψιν αρκετές (σε ορισμένες λειτουργίες και όλες) οι πιθανές περιπτώσεις λάθος εισόδου. Σε κάθε περίπτωση τυπώνεται μήνυμα λάθους.
- Τέλος, έχουν υλοποιηθεί όλα όσα ζητούνται στην εκφώνηση αλλά και αναφέρθηκαν στο piazza.

Compilation και εκτελέσιμο πρόγραμμα:
--------------------------------------
- Στο παραδοτέο directory υπάρχει το Makefile μέσω του οποίου μπορούν να παραχθούν τα εκτελέσιμα προγράμματα. Εκτελώντας την εντολή make παράγεται το εκτελέσιμο πρόγραμμα με όνομα travelMonitorClient και το εκτελέσιμο με όνομα monitorServer.
- Εφαρμόζεται separate compilation, δηλαδή πρώτα παράγονται όλα τα object file και τελικά μέσω αυτών παράγεται το εκτελέσιμο πρόγραμμα.
- Όπως αναφέρεται και στην εκφώνηση, εκτελούμε το travelMonitorClient, στο όποιο έπειτα από τα κατάλληλα forks και exec calls τα παιδιά "τρέχουν" το εκτελέσιμο monitorServer.
- Για την εκτέλεση του προγράμματος πρέπει να δοθούν τα ορίσματα τα οποία περιγράφονται στην εκφώνηση. Διαφορετικά εκτυπώνεται μήνυμα λάθους. Δηλαδή, η εκτέλεση γίνεται ως εξής:
	./travelMonitorClient –m numMonitors -b socketBufferSize -c cyclicBufferSize -ssizeOfBloom -i input_dir -t numThreads
 *(τα ορίσματα μπορούν να δοθούν με οποιαδήποτε σειρά )


Επικοινωνία μέσω sockets
------------------------

Η επικοινωνία μεταξύ του travelMonitorClient και των monitorServer γίνεται μέσω sockets. Στην επικοινωνία αυτή ο κάθε monitorServer είναι ο server και ο travelMonitorClient είναι ο client. Πιο συγκεκριμένα:
- Κάθε ένας monitorServer δημιουργεί ένα listening socket, δηλαδή εκτελεί τις λειτουργίες socket, bind, listen και στο τέλος accept έτσι ώστε να δεχθεί συνδέσεις. Άρα εκτελεί τα "χρέη" ενός server.
- Αντίστοιχα, ο travelMonitorClient κάνει connect στο αντίστοιχο socket του κάθε monitorServer.
- Επομένως κάθε ένας (από τους numMonitors) monitorServers δημιουργεί ένα listening socket στο οποίο δέχεται ακριβώς ένα αίτημα σύνδεσης από τον travelMonitorClient.
- Έτσι αφού ο travelMonitorClient συνδεθεί σε κάθε ένα από αυτά τα sockets (και αποθηκεύοντας τον descriptor του καθενός), μπορεί πλέον να επικοινωνεί με κάθε ένα monitorServer μέσω του αντίστοιχου socket.
- Κάθε ένα listening socket που δημιουργείται από τα monitorServers αντιστοιχεί και σε ένα port. Ξεκινώντας από ένα προκαθορισμένο port, σε κάθε ένα monitorServers αντιστοιχεί και το αμέσως επόμενο port.
Πιο συγκεκριμένα, έχει οριστεί μέσω #define το αρχικό port να είναι το 9003. Έτσι, το πρώτο monitorServers δημιουργεί το socket στο port 9003, το δεύτερο monitorServers στο port 9004, το τρίτο monitorServers στο port 9005 κ.ο.κ.
Ο travelMonitorClient, γνωρίζει ποιο port αντιστοιχεί στο κάθε monitorServers server έτσι ώστε να κάνει connect.
Επίσης, ο travelMonitorClient βρίσκει την διεύθυνση IP του μηχανήματος στο οποίο τρέχουν τόσο ο travelMonitorClient όσο και οι monitorServers μέσω των συναρτήσεων gethostname και gethostbyname.

Αφού δημιουργηθεί η σύνδεση μέσω των sockets, η επικοινωνία γίνεται ακριβώς με τον ίδιο τρόπο με την εργασία 2 μέσω read/write.
Αναλυτικές λεπτομέρειες εξηγούνται στο README της εργασίας 2. 
Τα βασικά σχόλια είναι:

-Όσον αφορά το socketBufferSize:
Η παράμετρος socketBufferSize μπορεί να είναι αρκετά μικρότερη από ότι τα μηνύματα που θέλουμε να στείλουμε. Αρχικά οι μόνοι τύποι μηνυμάτων που στέλνονται μεταξύ travelMonitorClient και Monitors είναι strings και bloomFilters. Επίσης, για την αποστολή strings χρησιμοποιώ ένα "πρωτόκολο" κατά το οποίο στέλνεται πρώτα το μήκος του string που πρόκειται να σταλθεί έτσι ώστε να γνωρίζει ο παραλήπτης πόσα bytes πρόκειται να διαβάσει. Επομένως για την αποστολή ενός string, χρειάζεται να προηγηθεί πρώτα η αποστολή ενός integer. Για την αποστολή/ανάγνωση μηνυμάτων έχω υλοποιήσει αντίστοιχες συναρτήσεις οι οποίες διαχειρίζονται το "πρόβλημα" του socketBufferSize και στέλνουν τα μηνύματα αυτά με κατάλληλο τρόπο.
Πιο συγκεκριμένα, για την αποστολή strings έχω υλοποιήσει τις συναρτήσεις: sendMessage και readMessage (κα sendInt, readInt για την αποστολή/ανάγνωση του μήκους του string).
Για την αποστολή ενός string αρχικά στέλνεται το μήκος του string που πρόκειται να σταλθεί μέσω της συνάρτησης sendInt. Σε περίπτωση που το socketBufferSize είναι μεγαλύτερο από το sizeOf(int), τότε η sendInt απλά στέλνει τον αριθμό με ένα μήνυμα μεγέθους sizeOf(int). Αν το socketBufferSize είναι μικρότερο από το sizeOf(int), τότε ο αριθμός στέλνεται σε "κομμάτια", δηλαδή με πολλαπλά μηνύματα το πολύ μεγέθους socketBufferSize. Στην συνέχεια με μια επαναληπτική διαδικασία στέλνουμε το string σε "κομμάτια" όπου το κάθε ένα έχει μέγεθος το πολύ socketBufferSize. Στην περίπτωση όπου το string που θέλουμε να στείλουμε είναι μεγαλύτερο από socketBufferSize τότε όλα τα μηνύματα/"κομμάτια" πλην του τελευταίου είναι μεγέθους socketBufferSize ενώ το τελευταίο ενδεχομένως να είναι λιγότερα από socketBufferSize. Αντίστοιχα, για το διάβασμα του string αρχικά διαβάζεται το μήκος αυτού του string μέσω της readInt. Στην συνέχεια, εφόσον γνωρίζουμε το μήκος του string, μέσω μιας επαναληπτικής διαδικασίας διαβάζουμε το string σε "κομμάτια" γνωρίζοντας μέσω του μήκους του string το μέγεθος του επόμενου "κομματιού" που πρόκειται να διαβάσουμε. Τελικά ενώνοντας τα κομμάτια αυτά έχουμε το ενιαίο string.
Για την αποστολή/ανάγνωση ενός bloomFilter ακολουθείται παρόμοια διαδικασία από τις συναρτήσεις: sendBloom και readBloom. Η βασική διαφορά είναι ότι δεν χρειάζεται να στέλνουμε το μέγεθος του bloomFilter (όπως κάνουμε με το μήκος του string) καθώς είναι πάντα το ίδιο (bloomSize) και είναι γνωστό τόσο από τον travelMonitorClient όσο και από τα Monitors. Ένα bloomFilter είναι ένας πίνακας από bytes. Επομένως στέλνουμε το bloomFilter σε "κομμάτια" μεγέθους socketBufferSize, δηλαδή στέλνουμε κάθε φορά socketBufferSize θέσεις του πίνακα. Προφανώς το τελευταίο μήνυμα μπορεί να είναι μικρότερου μεγέθους από socketBufferSize. Αντίστοιχα για την ανάγνωση μέσα σε μια επαναληπτική διαδικασία διαβάζουμε κάθε φορά socketBufferSize bytes και τα αντιγράφουμε κάθε φορά στην κατάλληλη θέση ενός ενιαίου πίνακα bloomSize μεγέθους έτσι ώστε να "συνθέσουμε" το συνολικό bloomFilter.
Έτσι έχουμε καταφέρει κάθε μήνυμα να είναι το πολύ μεγέθους socketBufferSize ανεξαρτήτως από τον τύπο και το μέγεθος του μηνύματος που θέλουμε να στείλουμε/διαβάσουμε. Η μόνη εξαίρεση είναι το πρώτο μήνυμα που "ανταλλάζουν" travelMonitorClient και Monitor και περιέχει το socketBufferSize. Έπειτα από αυτό το μήνυμα, όλα τα επόμενα μηνύματα στέλνονται μέσω των συναρτήσεων που εξηγούνται παραπάνω και στέλνουν πάντα μηνύματα το πολύ μεγέθους socketBufferSize.
Οι παραπάνω συναρτήσεις υλοποιούνται στο αρχείο socketReadWrite.c.
 ΠΑΡΑΤΗΡΗΣΗ: Το socketBufferSize δεν έχει κάποιο κάτω όριο. Το πρόγραμμα λειτουργεί κανονικά ακόμα και για socketBufferSize = 1 byte στέλνοντας μόνο μηνύματα ενός byte καθ' όλη την διάρκεια της εκτέλεσης.

-Επιπλέον σχόλια:
Το parent process διαβάζει μόνο από sockets τα οποία περιέχουν δεδομένα "για διάβασμα", δηλαδή σε περιπτώσεις όπου θέλουμε να διαβάσουμε από πολλά παιδιά συγχρόνως (π.χ. όταν όλα τα παιδιά στέλνουν τα bloomFilters τους) ο travelMonitorClient δεν μπλοκάρει ποτέ περιμένοντας κάποιο παιδί. Αυτό επιτυγχάνεται με την χρήση της poll() (της βιβλιοθήκης <poll.h>). Μέσω της poll, κάθε φορά ελέγχουμε σε ποια sockets υπάρχουν δεδομένα για διάβασμα και διαβάζουμε μόνο από αυτά τα sockets. Έτσι, το parent process δεν περιμένει ποτέ κάποιο αργό παιδί, αντιθέτως διαβάσει κάθε φορά τα δεδομένα των "γρήγορων" παιδιών τα οποία έχουν ήδη σταλεί. Το παραπάνω περιέχεται εσωτερικά μιας επαναληπτικής διαδικασίας. Έτσι, σε κάθε επανάληψη διαβάζει ένα μήνυμα από όσα παιδιά έχουν προλάβει να στείλουν. Όταν ένα παιδί στείλει όλα του τα δεδομένα, στέλνει ένα προκαθορισμένο μήνυμα έτσι ώστε να δείξει στον πατέρα ότι έστειλε όλα του τα δεδομένα. Έτσι, όταν ο πατέρας έχει λάβει αυτό το προκαθορισμένο μήνυμα από όλα τα παιδιά, η επαναληπτική διαδικασία ολοκληρώνεται καθώς έχουμε διαβάσει όλα τα δεδομένα όλων των παιδιών.


Threads - Cyclic Buffer
-----------------------

Κάθε monitorServer δημιουργεί numThreads threads (μέσω της pthread_create) και αποθηκεύει το id του κάθε thread σε έναν πίνακα numThreads θέσεων.
Η "δουλεία" του κάθε thread είναι να διαβάζει ένα μονοπάτι ενός αρχείου από τον κυκλικό buffer, να διαβάζει τις εγγραφές του αρχείου αυτού και να τις εκχωρεί στην βάση δεδομένων. Η διαδικασία αυτή γίνεται επαναληπτικά από κάθε thread.
Πιο συγκεκριμένα:
- Αρχικά, πριν ο monitorServer δημιουργήσει τα threads, δημιουργεί και αρχικοποιεί ένα αντικείμενο τύπου cyclicBuffer (ορίζεται στο αρχείο threadFunctions.c). Κάθε τέτοιο αντικείμενο αποτελείται από έναν πίνακα συμβολοσειρών (char *) cyclicBufferSize θέσεων. Επίσης, αποτελείται από έναν ακέραιο (start) όπου "δείχνει" σε ποια θέση του πίνακα έχει γραφτεί το πρώτο μονοπάτι αρχείου κάθε τρέχουσα χρονική στιγμή, έναν ακέραιο (end) όπου "δείχνει" σε ποια θέση του πίνακα έχει γραφτεί το τελευταίο μονοπάτι αρχείου κάθε τρέχουσα χρονική στιγμή καθώς και έναν ακέραιο (count) που "δείχνει" πόσα μονοπάτια αρχείων περιέχονται στον buffer κάθε τρέχουσα χρονική στιγμή.
- To starting point του κάθε thread είναι η συνάρτηση obtainFiles (που υπάρχει στο αρχείο threadFunctions.c).
Η διαδικασία που ακολουθεί κάθε ένα thread είναι:
- Μέσω ενός condition variable (cond_nonempty) ελέγχει εάν ο buffer είναι άδειος. Εάν είναι άδειος τότε μπλοκάρει στο condition variable έως ότου τοποθετηθεί τουλάχιστον ένα μονοπάτι αρχείου στον buffer, δηλαδή γίνει τουλάχιστον ένα pthread_cond_signal στο condition variable cond_nonempty.
- Εφόσον ο buffer δεν είναι άδειος, διαβάζει την πρώτη συμβολοσειρά από τον buffer (χρησιμοποιώντας το πεδίο start του cyclic buffer) και αλλάζει κατάλληλα τα πεδία start και count.
- Στην συνέχεια, αφού έχει διαβάσει το μονοπάτι του αρχείου πρέπει να διαβάσει το αρχείο και να εισάγει τις εγγραφές στην βάση.
- Καθώς πολλά threads μπορεί να επιχειρήσουν να ενημερώσουν ταυτόχρονα την (κοινόχρηστη) βάση, χρησιμοποιώ ένα binary mutex. Έτσι κάθε thread πριν να εισάγει μια εγγραφή ενός αρχείου στην βάση εκτελεί ένα pthread_mutex_lock στο mutex updateData. Σε περίπτωση που κάποιο άλλο thread ενημερώνει την βάση εκείνη την στιγμή τότε θα αναγκαστεί να "περιμένει" μέχρι να ολοκληρώσει την εισαγωγή της εγγραφής στην βάση. Όταν κανένα thread δεν ενημερώνει την βάση τότε "περνά" από το mutex και αρχίζει να εισάγει τις εγγραφές. Όταν εισαχθεί η εγγραφή εκτελεί ένα pthread_mutex_unlock έτσι ώστε να "απελευθερώσει" το mutex και να μπορούν και τα υπόλοιπα thread να ενημερώσουν την βάση.
Επομένως, το critical section είναι η εισαγωγή μιας εγγραφής βάση, καθώς θέλουμε τα critical section να είναι όσο μικρότερα γίνεται. Τα mutex lock/unlock όσον αφορά την εισαγωγή των εγγραφών στην βάση βρίσκονται στο αρχείο database.c (στο directory Database) και συγκεκριμένα εσωτερικά της συνάρτησης readCitizenRecordSFile η οποία είναι υπεύθυνη για την ανάγνωση ενός αρχείου και την εισαγωγή των εγγραφών του στην βάση. Άρα, κατά την διάρκεια διαβάσματος του κάθε αρχείου, πριν μια εγγραφή εισαχθεί στην βάση εκτελείται ένα mutex lock και αφού εισαχθεί ένα mutex unlock.
- Τέλος, χρησιμοποιείται μια μεταβλητή (totalFiles) η οποία δείχνει τον συνολικό αριθμό των αρχείων που πρέπει να διαβαστούν. Κάθε φορά, αφού ένα thread τελειώσει με την επεξεργασία ενός αρχείου μειώνει κατά ένα την μεταβλητή αυτή. Εάν αυτό ήταν το τελευταίο αρχείο (δηλαδή το totalFiles έγινε ίσο με μηδέν), τότε μέσω ενός condition variable (parsingEnded) ενημερώνει τον monitorServer ότι το διάβασμα των αρχείων και η εισαγωγή των εγγραφών στην βάση έχει ολοκληρωθεί και η βάση είναι πλέον "έτοιμη". Η μεταβλητή αυτή "προστατεύεται" από ένα mutex (totalFilesMutex) καθώς πολλά threads μπορεί να επιχειρήσουν να την αλλάξουν ταυτόχρονα.
- Αφού ολοκληρωθούν τα παραπάνω βήματα, το κάθε thread εκτελεί ένα pthread_cond_signal στο condition variable cond_nonfull έτσι ώστε να "δείξει" στον monitorServer ότι πλέον ο buffer δεν είναι γεμάτος (αφού μόλις διαβάστηκε ένα μονοπάτι αρχείου).

Η παραπάνω διαδικασία εκτελείται επαναληπτικά έως ότου ο monitorServer (δηλαδή το αρχικό thread) ενημερώσει τα threads ότι πρέπει να τερματίσουν. Το πως τα ενημερώνει εξηγείται στην συνέχεια.

Ο monitorServer (δηλαδή το αρχικό thread) αναλαμβάνει να "γεμίζει" τον buffer προσθέτοντας σε αυτόν μονοπάτια αρχείων τα οποία θα διαβάσουν τα threads. Έτσι κάνοντας traverse τα directories τα οποία του έχουν ανατεθεί, καλεί κάθε φορά την συνάρτηση producer μέσω της οποίας τοποθετεί να μονοπάτια των αρχείων στον buffer.
Πιο αναλυτικά, για κάθε ένα μονοπάτι αρχείου:
- Αρχικά, αυξάνει κατάλληλα την μεταβλητή totalFiles με τον αριθμό των μονοπατιών που πρόκειται να προστεθούν στον buffer.
- Μέσω ενός condition variable (cond_nonfull) ελέγχει εάν ο buffer είναι γεμάτος. Εάν είναι γεμάτος τότε μπλοκάρει στο condition variable έως ότου διαβαστεί τουλάχιστον ένα μονοπάτι αρχείου από τον buffer, δηλαδή γίνει τουλάχιστον ένα pthread_cond_signal στο condition variable cond_nonfull από κάποιο thread.
- Εφόσον ο buffer δεν είναι γεμάτος, τοποθετεί μια συμβολοσειρά στον buffer (χρησιμοποιώντας το πεδίο end του cyclic buffer) και αλλάζει κατάλληλα τα πεδία end και count.
- Αφού τοποθετήσει το μονοπάτι στον buffer, εκτελεί ένα pthread_cond_signal στο condition variable cond_nonempty έτσι ώστε να "δείξει" στα threads ότι πλέον ο buffer δεν είναι άδειος (αφού μόλις τοποθετήθηκε ένα μονοπάτι αρχείου στον buffer).

Η παραπάνω διαδικασία εκτελείται επαναληπτικά έως ότου τοποθετηθούν στον buffer όλα τα αρχεία των directories που έχουν ανατεθεί στον monitorServer.

Αφού τοποθετήσει όλα τα αρχεία στον buffer, ο monitorServer πρέπει να περιμένει έτσι ώστε να διαβαστούν όλα αυτά τα αρχεία και να ενημερωθεί κατάλληλα η βάση δεδομένων έτσι ώστε να μπορεί να στείλει τα bloomFilters στον travelMonitorClient.
Αυτό επιτυγχάνεται μέσω ενός condition variable (parsingEnded) καθώς και ενός μετρητή (totalFiles).
Πιο συγκεκριμένα:
- Όπως αναφέρθηκε και προηγουμένως, κάθε φορά που ένα thread τελειώσει με την επεξεργασία ενός αρχείου και εισάγει τις εγγραφές του στην βάση μειώνει κατά ένα την μεταβλητή totalFiles. Εάν το totalFiles γίνει ίσο με μηδέν, τότε το thread που διάβασε το τελευταίο αρχείο εκτελεί ένα pthread_cond_signal στο condition variable parsingEnded.
- O monitorServer αφού τοποθετήσει όλα τα αρχεία στον buffer, ελέγχει εάν το totalFiles έχει γίνει ίσο με μηδέν και αν δεν έχει γίνει εκτελεί ένα pthread_cond_wait στο condition variable parsingEnded. Έτσι θα "ξυπνήσει" αφού έχει διαβαστεί το τελευταίο αρχείο από ένα thread και έχει ενημερωθεί η βάση κατάλληλα.
- Αφού "περάσει" αυτό το βήμα, η βάση είναι ενημερωμένη και μπορεί πλέον να στείλει τα bloomFilters στο travelMonitorClient.

Τα threads τερματίζουν μόνο όταν δοθεί η εντολή /exit από τον χρήστη. Όταν γίνει αυτό, ο monitorServer θέτει ένα flag (endThreads) σε 1 και στην συνέχεια εκτελεί ένα pthread_cond_broadcast στο condition variable cond_nonempty έτσι ώστε να ξυπνήσει όλα τα threads.
Κάθε threads έπειτα από κάθε κλήση pthread_cond_wait στο condition variable cond_nonempty ελέγχουν αν το endThreads είναι ίσο με 1 και αν είναι τότε σταματάν την επαναληπτική διαδικασία και τερματίζουν.
Ο monitorServer έπειτα από το pthread_cond_broadcast εκτελεί ένα pthread_join για κάθε ένα thread έτσι ώστε να περιμένει όλα τα threads να τερματίσουν.

Παρατήρηση: Η υλοποίηση του cyclic buffer είναι βασισμένη στο παράδειγμα producer-consumer των διαφανειών του μαθήματος.


Επιπλέον παρατηρήσεις:
---------------------------
- Όπως αναφέρθηκε και παραπάνω, το socketBufferSize μπορεί να πάρει οποιαδήποτε τιμή (ακόμη και 1 byte). Η τιμή αυτή βέβαια, δεν πρέπει να ξεπερνά τα όρια χωρητικότητας των sockets (το οποίο διαφέρει από μηχάνημα σε μηχάνημα).
- Inconsistent εγγραφές στα αρχεία εισόδου απορρίπτονται ακριβώς όπως περιγραφόταν στην εργασία 1 και 2. Ωστόσο δεν εκτυπώνονται τα αντίστοιχα μηνύματα λάθους καθώς στην εκφώνηση αναφέρεται πως δεν θα υπάρχουν inconsistent εγγραφές καθώς και προτάθηκε από τους διδάσκοντες στην παρουσίαση της άσκησης να μην εκτυπώνονται αυτά τα μηνύματα.
- Σε περίπτωση όπου ο αριθμός των χωρών/directories (έστω numOfCountries) στο input directory είναι μικρότερος από το numMonitors, τότε ανατίθεται μία χώρα στα πρώτα numOfCountries monitors, ενώ τα υπόλοιπα τερματίζουν. Επομένως έχουμε numOfCountries ενεργά monitors και όχι numMonitors.
- Όλες οι υπόλοιπες δομές/λειτουργίες που χρησιμοποιούνται και δεν εξηγούνται είναι ακριβώς οι ίδιες με αυτές της εργασίας 2.


Travel Monitor Client:
---------------------------
Η διαδικασία που ακολουθεί ο travelMonitorClient είναι η εξής:
- Διαβάζει το directory που δόθηκε σαν όρισμα, εντοπίζει τις χώρες/φακέλους που περιέχονται σε αυτό και τις κρατά σε μια ταξινομημένη λίστα.
- Με Round Robin κατανομή, προσθέτει σε μια λίστα για κάθε παιδί τις χώρες για τις οποίες θα είναι υπεύθυνο. Για κάθε παιδί, ο πατέρας έχει μια λίστα με τις χώρες οι οποίες του έχουν ανατεθεί. Έτσι, κάθε φορά που αναθέτει μια χώρα σε ένα παιδί, την εισάγει και στην αντίστοιχη λίστα.
- Στην συνέχεια μέσω μιας επαναληπτικής διαδικασίας (τόσων επαναλήψεων όσος και ο αριθμός των monitors) κάνει fork. Έπειτα από το fork η διεργασία παιδί, καλεί την execvp με όρισμα το εκτελέσιμο monitorServer καθώς και τα επιπλέον ορίσματα που περιγράφονται στην εκφώνηση. Η διεργασία πατέρας, αρχικοποιεί μια λίστα στην οποία θα αποθηκευτούν τα bloomFilters τα οποία θα του στείλει αυτό το παιδί. Επίσης αποθηκεύει το process id του παιδιού.
- Έπειτα, όπως περιγράφηκε και παραπάνω, κάνει connect στο listening socket το οποίο έχει δημιουργήσει το κάθε παιδί βρίσκοντας την διεύθυνση IP του μηχανήματος και χρησιμοποιώντας το port που αντιστοιχεί στο κάθε παιδί.
- Στην συνέχεια, ξεκινάει να διαβάζει τα bloomFilters που του στέλνουν τα παιδία. Όπως αναφέρθηκε και παραπάνω, διαβάζει μόνο από όσα sockets περιέχουν δεδομένα, χωρίς να μπλοκάρει περιμένοντας "αργά" παιδιά. Ο πατέρας έχει μια λίστα από bloomFilters για κάθε παιδί. Κάθε φορά που διαβάζει ένα bloomFilter από ένα παιδί, το εισάγει στην αντίστοιχη λίστα.
- Μόλις διαβαστούν όλα τα bloomFilters από όλα τα παιδία, ο travelMonitor είναι έτοιμος να δεχθεί εντολές από τον χρήστη. Αφού εκτυπώσει το αντίστοιχο μήνυμα, μέσα σε μια επαναληπτική διαδικασία περιμένει να διαβάσει κάποια εντολή από τον χρήστη και μόλις διαβαστεί η εντολή καλεί την συνάρτηση userRequest η οποία εκτελεί την αντίστοιχη εντολή. Η κάθε εντολή εξηγείται στην συνέχεια.


Monitor Server:
---------------
Η διαδικασία που ακολουθεί ο monitorServer είναι η εξής:
- Διαβάζει τα ορίσματα που δόθηκαν κατά την εκτέλεση.
- Όπως αναφέρθηκε και παραπάνω, δημιουργεί ένα listening socket στο port το οποίο του δόθηκε σαν όρισμα, δηλαδή εκτελεί τις λειτουργίες: socket, bind, listen.
- Μέσω τις accept, περιμένει αίτημα σύνδεσης στο socket από τον travelMonitorClient το οποίο και αποδέχεται.
- Αρχικοποιεί τον cyclic buffer, τα mutexes και τα condition variables.
- Δημιουργεί numThreads threads με starting point την συνάρτηση obtainFiles και αποθηκεύει τα id's τους σε έναν πίνακα.
- Στην συνέχεια διαβάζει ένα προς ένα τα directories που του έχουν ανατεθεί και μέσω της συνάρτησης producer τοποθετεί στον cyclic buffer τα μονοπάτια όλων των αρχείων που περιέχονται στα directories αυτά. Δηλαδή εκτελούνται οι λειτουργίες που περιγράφονται στην παράγραφο Threads - Cyclic Buffer.
- Περιμένει (μέσω του condition variable parsingEnded) μέχρι να διαβαστούν όλα τα αρχεία από τα threads και να εισαχθούν όλες οι εγγραφές στην βάση.
- Στέλνει όλα τα bloomFilters στον travelMonitorClient μέσω του socket. Η αποστολή των bloomFilters γίνεται ακριβώς με τον ίδιο τρόπο με την εργασία 2.
- Στην συνέχεια περιμένει να δεχτεί εντολές από τον travelMonitorClient μέσω του socket. Οι εντολές αυτές είναι κατά κύριο λόγο ίδιες με τις εργασίας 2 και εξηγούνται στην συνέχεια.
- Όταν δεχθεί την εντολή /exit από τον travelMonitorClient τότε μέσω της συνάρτησης writeLogFile και των αντίστοιχων counters που χρησιμοποιούνται γράφει το logFile με τον τρόπο που περιγράφεται στην εκφώνηση (ίδιο με εργασία 2). Στην συνέχεια, όπως εξηγήθηκε και παραπάνω, αλλάζει την μεταβλητή endFlag σε ένα και κάνει broadcast στα threads έτσι ώστε να "ξυπνήσουν" από τα condition variables και να τερματίσουν. Περιμένει τα threads να τερματίσουν μέσω της pthread_join, αποδεσμεύει κατάλληλα όλη την δυναμικά δεσμευμένη μνήμη, καταστρέφει τα mutexes και τα condition variables, κλείνει το socket και τελικά τερματίζει. 


Εντολές εφαρμογής:
------------------
 /travelRequest citizenID date countryFrom countryTo virusName
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Αρχικά το travelMonitorClient βρίσκει σε ποιό monitorServer έχει ανατεθεί η χώρα countryFrom (έστω monitorX).
Στην συνέχεια ελέγχει αν το citizenID έχει εισαχθεί στο bloomFilter που του έστειλε το monitorX για τον ιό virusName.
Αν η απάντηση είναι αρνητική τότε το αίτημα απορρίπτεται και εκτυπώνεται το αντίστοιχο μήνυμα.
Αλλιώς ο travelMonitor "ρωτάει" το monitorX για το αν έχει εμβολιαστεί ο citizenID, δηλαδή στέλνει /travelRequest (έτσι ώστε να καταλάβει το monitor για τι αίτημα πρόκεται) ακολουθούμενο από το citizenID και το virusName.
Αφού διαβάσει τα παραπάνω μηνύματα, το monitorX, ελέγχει εάν ο πολίτης έχει εμβολιαστεί για τον ιό αυτό, δηλαδή ελέγχει εάν ο πολίτης υπάρχει στην vaccinated_skipList του ιού virusName (ακριβώς όπως κάναμε και στην εργασία 1). Σε περίπτωση που έχει εμβολιαστεί, στέλνει στον πατέρα το μήνυμα YES ακολουθούμενο από την ημερομηνία εμβολιασμού. Σε περίπτωση που δεν έχει εμβολιαστεί, τότε το monitorX στέλνει ΝΟ. Στην πρώτη περίπτωση, το monitorX περιμένει απάντηση από τον πατέρα έτσι ώστε να μάθει αν το αίτημα τελικά εγκρίθηκε ή όχι (και να αυξήσει κατάλληλα τους accepted/rejected counters).
O travelMonitor διαβάζει την απάντηση του monitorX. Στην περίπτωση που είναι YES, ελέγχει εάν η ημερομηνία εμβολιασμού είναι εντός 6 μηνών από το date. Εάν είναι, τότε το αίτημα εγκρίνεται ενώ αν δεν είναι τότε απορρίπτεται. Και στις 2 περιπτώσεις, στέλνει την αντίστοιχη ενημέρωση στο monitorX, έτσι ωστε να αυξήσει κατάλληλα τον αντίστοιχο counter accepted/rejected. Αν ο monitorX απάντησε NO, τότε το αίτημα απορρίπτεται.
Κάθε φορά τόσο ο travelMonitorClient όσο και το MonitorX (δηλαδή το monitorServer που διαχειρίζεται την χώρα countryFrom) αυξάνουν κατάλληλα τους counters που κρατάνε σχετικά με τα αιτήματα που δέχτηκαν.

Παρατήρηση: Αν το travel date που δόθηκε στην εντολή είναι πριν την ημερομηνία εμβολιασμού του πολίτη τότε εκτυπώνεται REQUEST REJECTED – YOU ARE NOT VACCINATED, δηλαδή σαν να μην έχει εμβολιαστεί ο πολίτης (όπως προτάθηκε και στο piazza).

 /travelStats virusName date1 date2 [country]
- - - - - - - - - - - - - - - - - - - - - - - - -
Κάθε φορά που ο travelMonitor λαμβάνει ένα αίτημα μέσω της /travelRequest αποθηκεύει τις πληροφορίες για κάθε αίτημα σε μια λίστα. Δηλαδή έχουμε μια λίστα με όλα τα αιτήματα τα οποία έχει δεχθεί ο travelMonitor. Για κάθε ένα αίτημα αποθηκεύεται ο ιός τον οποίο αφορά το αίτημα, η χώρα την οποία αφορά το αίτημα (countryTo), η ημερομηνία του ταξιδιού που αφορά το αίτημα καθώς και το αν έγινε αποδεκτό ή όχι.
Επομένως για να υπολογίσουμε τα στατιστικά, ελέγχουμε κάθε αίτημα της λίστας για το αν αφορά τον δοθέντα ιό, εάν βρίσκεται ενδιάμεσα στις δοθέντες ημερομηνίες και αν αφορά την δοθείσα χώρα προορισμού (εάν έχει δοθεί). Εάν πληρούνται αυτές οι προϋποθέσεις για ένα αίτημα, αυξάνουμε έναν συνολικό counter καθώς και έναν accepted/rejected counter ανάλογα με το αν το αίτημα αυτό είχε γίνει αποδεκτό η όχι.
Αφού ελέγξουμε όλα τα αιτήματα της λίστας, έχουμε υπολογίσει τα στατιστικά που θέλουμε, τα οποία και τυπώνουμε.
Το όρισμα country (αν αυτό έχει δοθεί) αντιστοιχεί στο όρισμα countryTo των αιτημάτων /travelRequest (όπως έχει αναφερθεί και στο piazza).
Τα στατιστικά που εκτυπώνονται είναι:
- Αν έχει δοθεί το country: Ο συνολικός αριθμός των travelRequests που έγιναν και περιείχαν σαν countryTo την δοθείσα χώρα και το date (ημερομηνία του ταξιδιού) ήταν ανάμεσα στα date1 και date2. Επίσης, το πόσα από αυτά έγιναν αποδεκτά και πόσα όχι.
- Αν δεν έχει δοθεί το country: Ο συνολικός αριθμός των travelRequests που έγιναν και το date (ημερομηνία του ταξιδιού) ήταν ανάμεσα στα date1 και date2 καθώς και το πόσα από αυτά έγιναν αποδεκτά και πόσα όχι.

/addVaccinationRecords country
- - - - - - - - - - - - - - - -
Αρχικά το travelMonitor βρίσκει σε ποιό monitor έχει ανατεθεί η χώρα country (έστω monitorX).
O travelMonitorClient στένει στο monitorX μέσω του socket το μήνυμα (string) /addVaccinationRecords (έτσι ώστε να καταλάβει το monitor για τι αίτημα πρόκειται) ακολουθούμενο από το country.
Στην συνέχεια περιμένει να διαβάσει τα ανανεωμένα bloomFilters που θα του στείλει το monitorX τα οποία και αποθηκεύει στην λίστα με τα bloomFilters που αντιστοιχεί στο monitorX.
Σε περίπτωση που το monitorX δεν βρει κανένα νέο αρχείο τότε δεν στέλνει κανένα bloomFilter καθώς δεν προστέθηκε κανένα νέο δεδομένο σε αυτά. Αντίστοιχα, σε αυτήν την περίπτωση, ο πατέρας δεν διαβάζει κανένα bloomFIlter, και κρατάει αυτά που έχει ήδη.

Αντίστοιχα το monitorX μόλις λάβει ένα μήνυμα /addVaccinationRecords διαβάζει την χώρα για την οποία πρόκειται και ψάχνει στο directory της χώρας αυτής για νέα αρχεία (μέσω της συνάρτησης readNewFiles του αρχείου readFiles.c). Κάθε monitor έχει μονίμως σε μια λίστα τα ονόματα των αρχείων τα οποία έχει ήδη διαβάσει και των οποίων οι εγγραφές έχουν εισαχθεί στην βάση δεδομένων. Επομένως η readNewFile για κάθε ένα αρχείο που βρίσκεται στα directory της χώρας που δόθηκε, ελέγχει αν υπάρχει κάποιο αρχείο το οποίο δεν περιέχεται στην λίστα αυτήν. Σε περίπτωση που βρει κάποιο τέτοιο αρχείο, το προσθέτει στον cyclic buffer μέσω της συνάρτησης produce.
Στην συνέχεια ακολουθεί η διαδικασία που περιγράφεται στην παράγραφο Threads - Cyclic Buffer έτσι ώστε να προστεθούν τα νέα αρχεία στον buffer από το monitorX και να διαβαστούν από τα threads και να εισαχθούν οι εγγραφές τους στην βάση δεδομένων.
Ο monitorServer αφού τοποθετήσει όλα τα νέα αρχεία στον buffer περιμένει μέχρι αυτά να διαβαστούν και οι εγγραφές τους να εισαχθούν στην βάση δεδομένων. Αυτό γίνεται μέσω του condition variable που εξηγήθηκε αναλυτικά παραπάνω.
Τέλος στέλνει τα ανανεωμένα bloomFilters στον travelMonitor.
Σε περίπτωση που δεν βρεθεί κανένα νέο αρχείο, τότε το monitorServer δεν στέλνει κανένα bloomFilter στον travelMonitorClient καθώς δεν προστέθηκε κανένα νέο δεδομένο και κατ' επέκταση δεν τροποποιήθηκε κανένα bloomFilter (δηλαδή τα bloomFilters που ήδη έχει ο πατέρας παραμένουν "ενημερωμένα").

/searchVaccinationStatus citizenID
- - - - - - - - - - - - - - - - - -
Το travelMonitorClient στέλνει σε όλα τα monitorServer /searchVaccinationStatus ακολουθούμενο από το citizenID μέσω των sockets.
Χρησιμοποιώντας την poll σε μια επαναληπτική διαδικασία διαβάζει τις απαντήσεις των παιδιών.
Όλα τα παιδιά τα οποία δεν βρίσκουν καμία εγγραφή για τον citizen απαντάνε το προκαθορισμένο μήνυμα ENDOF/SEARCHVACCINATIONSTATUS, και έτσι ο travelMonitorClient δεν περιμένει πια άλλη απάντηση από αυτά τα monitors.
To monitorServer το οποίο έχει πληροφορίες για τον citizen, στέλνει μέσω μηνυμάτων τις πληροφορίες αυτές τις οποίες και εκτυπώνει ο travel Monitor. Μόλις στείλει όλες τις πληροφορίες, στέλνει και αυτό ENDOF/SEARCHVACCINATIONSTATUS.
Όταν όλα τα monitors έχουν στείλει το μήνυμα ENDOF/SEARCHVACCINATIONSTATUS, τότε η διαδικασία ολοκληρώνεται καθώς έχουν διαβαστεί και εκτυπωθεί όλες οι πληροφορίες για τον citizen.

/exit
- - - -
Εάν ο χρήστης δώσει /exit τότε μέσω των sockets ο travelMonitorClient στέλνει σε όλα τα monitorServer το μήνυμα /searchVaccinationStatus. Στην συνέχεια:

- Τα monitorServers:
Mέσω της συνάρτησης writeLogFile και των αντίστοιχων counters που χρησιμοποιούνται γράφει το logFile με τον τρόπο που περιγράφεται στην εκφώνηση (ίδιο με εργασία 2). Στην συνέχεια, όπως εξηγήθηκε και παραπάνω, αλλάζει την μεταβλητή endFlag σε ένα και κάνει broadcast στα threads έτσι ώστε να "ξυπνήσουν" από τα condition variables και να τερματίσουν. Περιμένει τα threads να τερματίσουν μέσω της pthread_join, αποδεσμεύει κατάλληλα όλη την δυναμικά δεσμευμένη μνήμη, καταστρέφει τα mutexes και τα condition variables, κλείνει το socket και τελικά τερματίζει. 

- Ο travelMonitorClient:
Αφού στείλει σε όλα τα παιδιά το μήνυμα που αναφέρθηκε παραπάνω, γράφει το logFile μέσω της συνάρτησης writeLogFile και στην συνέχεια περιμένει μέσω τις wait όλα τα παιδιά να τερματίσουν. Αφού τερματίσουν όλα τα παιδιά αποδεσμεύει κατάλληλα την δυναμικά δεσμευμένη μνήμη, κλείνει τα ανοιχτά sockets που έχει για κάθε ένα παιδί και τελικά τερματίζει.










