Ιωάννης Καπετανγεώργης
Α.Μ.: 1115201800061

Προγραμματισμός Συστημάτων - Project 1
---------------------------------------

Γενικά σχόλια:
--------------
- Η υλοποίηση του πρώτου part της εργασίας περιέχεται στο directory με όνομα VaccineMonitor. Αντίστοιχα, η υλοποίηση του δεύτερου part περιέχεται στο directory με όνομα BashScript.
- Όλα τα αρχεία κώδικα είναι σχολιασμένα πολύ αναλυτικά και εξηγείται η κάθε λειτουργία που γίνεται στο κάθε σημείο.
- Όση μνήμη έχει δεσμευθεί δυναμικά κατά την εκτέλεση του προγράμματος, αποδεσμεύεται πριν το τέλος αυτού με ελεγχόμενο τρόπο και χωρίς να υπάρχουν απώλειες μνήμης η errors. Έχει ελεγχθεί μέσω του valgrind.
- Οι δομές που χρησιμοποιούνται στο πρόγραμμα έχουν οργανωθεί έτσι ώστε να μην υπάρχει καθόλου επικάλυψη πληροφορίας (σε κανένα από τα στοιχεία των πολιτών id,name,country,...), αλλά και σε κάθε περίπτωση να δεσμεύεται μόνο όση μνήμη πραγματικά χρειαζόμαστε. Περισσότερες λεπτομέρειες εξηγούνται παρακάτω.
- Ο κώδικας έχει χωριστεί σε πολλά αρχεία (.c και .h) ανάλογα με την λειτουργία που υλοποιούν έτσι ώστε να επιτευχθεί abstraction των δεδομένων αλλά και να είναι πιο κατανοητός και ευανάγνωστος ο συνολικός κώδικας. Επίσης επιτυγχάνεται πλήρης απόκρυψη πληροφορίας. Για κάθε αρχείο κώδικα (.c) (εκτός του αρχείου main.c που περιέχει μόνο την main) υπάρχουν και τα αντίστοιχα header αρχεία, τα οποία περιέχουν τις απαραίτητες δηλώσεις έτσι ώστε να παρέχεται το "interface" σε ένα άλλο αρχείο το οποίο χρησιμοποιεί τις λειτουργίες αυτές.
- Σε όλα τα σημεία που αποθηκεύεται μια συμβολοσειρά, χρησιμοποιώ τον τύπο char * (και όχι κάποιον στατικό πίνακα χαρακτήρων π.χ. char [50]) έτσι ώστε να δεσμεύεται μόνο όσος χώρος χρειάζεται για την αποθήκευση της συμβολοσειράς. Εξαίρεση σε αυτό αποτελούν μόνο κάποιοι προσωρινοί buffers κατά το διάβασμα εντολών του χρήστη και εγγραφών του αρχείου.
- Έχει υλοποιηθεί το απαραίτητο error checking σχετικά με την εισαγωγή των δεδομένων (τόσο από το input αρχείο όσο και από της εντολές του χρήστη). Έχουν ληφθεί υπόψιν αρκετές (σε ορισμένες λειτουργίες και όλες) οι πιθανές περιπτώσεις λάθος εισόδου. Σε κάθε περίπτωση τυπώνεται μήνυμα λάθους.
- Τέλος, έχουν υλοποιηθεί όλα όσα ζητούνται στην εκφώνηση αλλά και αναφέρθηκαν στο piazza.

Παραδοχές:
-----------
- To citizenId αποθηκεύεται σαν συμβολοσειρά (char *) (όπως περιγράφεται και στην εκφώνηση). Κάθε ένα id αποθηκεύεται μόνο μια φορά στην μνήμη ανεξαρτήτως το σε πόσες διαφορετικές skipList και σε πόσους κόμβους/επίπεδα της κάθε skipList περιέχεται. Το citizenId αποθηκεύεται σαν συμβολοσειρά εσωτερικά του hashTable (στον κόμβο που αντιστοιχεί στον πολίτη με αυτό το citizenId). Κάθε "αναφορά" σε αυτό το id στις skipLists γίνεται μέσω pointer (char *) στην συμβολοσειρά αυτή του hashTable. Έτσι, δεν έχουμε καθόλου data duplication όσον αφορά το citizenId (όπως φυσικά και για όλα τα άλλα στοιχεία των πολιτών). Περισσότερες λεπτομέρειες εξηγούνται παρακάτω στις αντίστοιχες παραγράφους.
- Η ημερομηνία τόσο στο αρχείο εντολών όσο και στης στολές του χρήστη πρέπει να έχει το format "dd-mm-yyyy" (όπως περιγράφεται και στην εκφώνηση). Σε κάθε άλλη περίπτωση (π.χ. "12/2/2020" ή "2020-2-12") εκτυπώνεται μήνυμα λάθος και η εγγραφή αγνοείται (ως μη έγκυρη). Επίσης πρέπει 1<=day<=30 , 1<=month<=12 και 1700<=year<=2021.
- Επίσης, και τα υπόλοιπα δεδομένα των εγγραφών που εισάγονται τόσο από το αρχείο όσο και από τις εντολές του χρήστη ελέγχονται ως προς την εγκυρότητα. Επομένως για να θεωρηθεί μια εγγραφή έγκυρη πρέπει:
	- τα firstName, lastName και country να είναι συμβολοσειρές που αποτελούνται αποκλειστικά από γράμματα χωρίς κενά.
	- τα virusName να είναι συμβολοσειρές που αποτελούνται αποκλειστικά από γράμματα, αριθμούς και ΤΟ ΠΟΛΥ μια παύλα ('-') χωρίς κενά.
- Καθώς χρησιμοποιώ κάποιους προσωρινούς στατικούς πίνακες (buffers) κατά το διάβασμα εγγραφών/εντολών, υποθέτω ότι:
	- το citizenId έχει το πολύ μήκος 20 χαρακτήρες
	- τα firstName, lastName, country, virusName έχουν το πολύ μήκος 50 χαρακτήρες

Compilation και εκτελέσιμο πρόγραμμα:
--------------------------------------
- Στο παραδοτέο directory υπάρχει το Makefile μέσω του οποίου μπορεί να παραχθεί το εκτελέσιμο πρόγραμμα. Εκτελώντας την εντολή make παράγεται το εκτελέσιμο πρόγραμμα με όνομα vaccineMonitor.
- Εφαρμόζεται separate compilation, δηλαδή πρώτα παράγονται όλα τα object file και τελικά μέσω αυτών παράγεται το εκτελέσιμο πρόγραμμα.
- Για την εκτέλεση του προγράμματος πρέπει να δοθούν τα ορίσματα τα οποία περιγράφονται στην εκφώνηση. Διαφορετικά εκτυπώνεται μήνυμα λάθους. Δηλαδή, η εκτέλεση γίνεται ως εξής:
	./vaccineMonitor -c citizenRecordsFile –b bloomSize
 *(τα ορίσματα μπορούν να δοθούν και με αντίθετη σειρά, δηλαδή: ./vaccineMonitor –b bloomSize -c citizenRecordsFile )
-Έπειτα από την επεξεργασία του αρχείου, η είσοδος του χρήση (για την εκτέλεση των αντίστοιχων εντολών) πρέπει να είναι όπως αυτή που περιγράφεται στην εκφώνηση. Αναλυτικότερα για κάθε μια λειτουργία παρακάτω.

Bloom Filter
--------------
Η υλοποίηση του bloom filter υπάρχει στο αρχείο bloomFilter.c. Για την υλοποίηση του χρησιμοποιώ τον τύπο uint8_t. Κάθε αντικείμενο τύπου uint8_t έχει μέγεθος 1 byte (δηλαδή 8 bits). Ο χρήστης δίνει το επιθυμητό μέγεθος του bloom filter σε bytes (bloomSize). Έτσι, το bloom filter είναι ένας "πίνακας" μεγέθους bloomSize από στοιχεία τύπου uint8_t. Δηλαδή έχει συνολικό μέγεθος bloomSize bytes, δηλαδή bloomSize*8 bits.
Κάθε φορά που θέλουμε να ελέγξουμε/τροποποιήσουμε ένα από τα bloomSize*8 bits, εντοπίζουμε σε ποια "θέση" του πίνακα βρίσκεται το bit αυτό, παίρνουμε το byte της θέσης αυτής, και χρησιμοποιώντας logical shifts και masking ελέγχουμε/τροποποιούμε το bit αυτό.
Η συναρτήσεις κατακερματισμού που χρησιμοποιώ είναι αυτές που μας δόθηκαν, χωρίς να έχουν τροποποιηθεί καθόλου.
Ο αριθμός Κ έχει γίνει defined σε 16.
Οι λειτουργίες που παρέχει το bloom filter είναι:
- createBloom : δημιουργία/αρχικοποίηση του bloom filter
- bloomInsert : εισαγωγή ενός πολίτη (δηλαδή ενός citizenId) στο bloom filter
- bloomExists : ελέγχει αν ένας πολίτης (δηλαδή το citizenId του πολίτη που δίνεται σαν όρισμα στην συνάρτηση) υπάρχει στο bloom filter. 

Skip List
------------
Η υλοποίηση της skip list υπάρχει στο αρχείο skipList.c. Η υλοποίηση έχει γίνει χρησιμοποιώντας λίστες. 
Πιο συγκεκριμένα, υπάρχει μία λίστα για τα επίπεδα της skipList. Δηλαδή κάθε κόμβος της λίστας επιπέδων (slLevelNode) αντιστοιχεί σε ένα επίπεδο της skipList. Επίσης κάθε ένας από αυτούς τους κόμβους περιέχει τον αριθμό του επιπέδου, έναν δείκτη στο αμέσως χαμηλότερο επίπεδο καθώς και μία λίστα με τα κλειδιά που περιέχονται στο επίπεδο αυτό (εξηγείται αμέσως μετά). Το χαμηλότερο επίπεδο είναι το επίπεδο 1 και περιέχει NULL στον δείκτη ο οποίος "δείχνει" στο αμέσως χαμηλότερο επίπεδο.
Όπως αναφέρθηκε κάθε επίπεδο έχει μια λίστα η οποία αντιστοιχεί στα κλειδιά (citizenId) που περιέχονται στο επίπεδο αυτό. Κάθε ένας κόμβος (slNode) των λιστών αυτών περιέχει: το κλειδί στο οποίο αναφέρεται ο κόμβος αυτός (char * , καθώς το id αποθηκεύεται στην μνήμη μόνο μια φορά στο hashTable), έναν δείκτη στον αντίστοιχο κόμβο (με ίδιο κλειδί) του αμέσως χαμηλότερου επιπέδου καθώς και έναν δείκτη στον επόμενο κόμβο της λίστας (δηλαδή στο επόμενο κλειδί) του επιπέδου αυτού. Επίσης, οι κόμβοι του χαμηλότερου επιπέδου (επίπεδο 1) περιέχουν την ημερομηνία εμβολιασμού του πολίτη καθώς και αντί για δείκτη στον αντίστοιχο κόμβο του αμέσως χαμηλότερου επιπέδου περιέχουν έναν δείκτη στην εγγραφή του πολίτη με το αντίστοιχο id.
Πιο αναλυτικά:
- Όπως ήδη αναφέρθηκε, οι κόμβοι όλων των επιπέδων πλην του χαμηλότερου περιέχουν έναν δείκτη στον αντίστοιχο κόμβο (με ίδιο κλειδί) του αμέσως χαμηλότερου επιπέδου. Οι κόμβοι του χαμηλότερου επιπέδου, στο ίδιο πεδίο περιέχουν έναν δείκτη στην εγγραφή του συγκεκριμένο πολίτη. Η εγγραφή αυτή είναι ένας κόμβος ενός hash table ο οποίος περιέχει το όνομα, το επίθετο, την χώρα και την ηλικία του πολίτη. Έτσι καταφέρνουμε να αποθηκεύουμε μόνο μια φορά τα στοιχεία του πολίτη στην μνήμη. Δηλαδή σε περίπτωση που ένας πολίτης έχει εισαχθεί σε 2 διαφορετικές skipList, ο αντίστοιχος κόμβος της κάθε skipList περιέχει έναν δείκτη στον ίδιο κόμβο του hashTable και τελικά τα δεδομένα (όνομα,επίθετο,κλπ.) αποθηκεύονται μόνο μια φορά, δηλαδή αποφεύγουμε την επανάληψη πληροφορίας. Περισσότερες πληροφορίες για το hashTable εξηγούνται παρακάτω.
Για να επιτευχθεί αυτό, δηλαδή ότι οι κόμβοι του τελευταίου επιπέδου "δείχνουν" μέσω του ίδιου πεδίου σε αντικείμενα διαφορετικού τύπου από ότι αυτά που δείχνουν οι κόμβοι των υψηλότερων επιπέδων έχω χρησιμοποιήσει void pointers (void *) και κάθε φορά γίνεται cast στον αντίστοιχο τύπο.
- Επίσης, όπως αναφέρθηκε και προηγουμένως, κάθε κόμβος της skipList αντιστοιχεί σε ένα κλειδί το οποίο και περιέχει. Στην πραγματικότητα κάθε κόμβος περιέχει έναν δείκτη σε συμβολοσειρά (δηλαδή char *). Η συμβολοσειρά αυτή αποθηκεύεται μόνο μια φορά στην μνήμη στον κόμβο του hashTable που αντιστοιχεί σε αυτόν τον πολίτη. Προφανώς μπορεί σε μια skipList να συναντάμε ένα citizenId σε έναν ή παραπάνω κόμβους (αν έχει "ανέβει" σε παραπάνω επίπεδα της skipList) αλλά και το ίδιο id μπορεί να περιέχεται σε πολλαπλές skipList διαφορετικών ιών. Ωστόσο το citizenId αποθηκεύεται μόνο μία φορά στην μνήμη (στο hashTable) και σε κάθε άλλο σημείο που το συναντάμε έχουμε έναν δείκτη σε αυτήν την συμβολοσειρά. Δηλαδή, δεν έχουμε καθόλου data duplication.
- Οι κόμβοι όλων των επιπέδων πλην του χαμηλότερου περιέχουν NULL στο πεδίο date (το οποίο είναι τύπου char*) καθώς η ημερομηνία αποθηκεύεται μόνο στο τελευταίο επίπεδο έτσι ώστε να μην έχουμε επανάληψη πληροφορίας. Επίσης, αν η skipList πρόκειται για not_vaccinated_persons skipList τότε και το τελευταίο επίπεδο περιέχει NULL στο πεδίο date καθώς δεν υπάρχει ημερομηνία εμβολιασμού

Συνοψίζοντας, μπορούμε να σκεφτούμε την skipList σαν μια λίστα από λίστες. Δηλαδή, μια λίστα επιπέδων όπου κάθε επίπεδο περιέχει μια λίστα από κλειδιά.
Επίσης, το ύψος της skipList αυξάνεται δυναμικά με την εισαγωγή στοιχείων σε αυτήν και κάθε φορά είναι δεσμευμένη μόνο όση μνήμη πραγματικά χρειάζεται η skipList.
Για τυπικούς λόγους, έχει οριστεί ένα μέγιστο όριο ύψους (30 ~ log(πληθυσμός της γης) ) το οποίο όμως στην πράξη υπάρχουν ελάχιστες πιθανότητες να το φτάσει.
Παρατήρηση: η μνήμη που δεσμεύει η skipList δεν σχετίζεται με το όριο ύψους (π.χ. δεν δεσμεύεται κάποια δομή μεγέθους 30), όπως αναφέρθηκε και προηγουμένως δεσμεύεται μόνο όση μνήμη πραγματικά χρειάζεται.
Επίσης, προφανώς, κάθε λίστα κάθε επιπέδου είναι ταξινομημένη με βάση το κλειδί citizenId.

Τέλος, όσον αφορά την αναζήτηση/εισαγωγή στην skipList "ξεκινάμε" από τον πρώτο κόμβο της λίστας του υψηλότερου επιπέδου και (έπειτα από συγκρίσεις των κλειδιών) μέσω των δεικτών που περιέχει κάθε κόμβος στο αντίστοιχο κλειδί/κόμβο του αμέσως χαμηλότερου επιπέδου τελικά καταλήγουμε στο χαμηλότερο επίπεδο (επίπεδο 1) σε χρόνο O(logn). 
Έπειτα από την εισαγωγή του νέου κλειδιού κάθε φορά μέσω ενός flip a coin (50% πιθανότητα) αποφασίζεται για το αν το νέο αυτό κλειδί θα εισαχθεί και στο αμέσως υψηλότερο επίπεδο. Δηλαδή (επιστρέφοντας από την αναδρομή) σε κάθε ένα επίπεδο υπάρχει 50% πιθανότητα το νέο κλειδί στο αμέσως υψηλότερο επίπεδο. Αν εισαχθεί στο αμέσως υψηλότερο επίπεδο, ακολουθείται η ίδια διαδικασία για να αποφασιστεί το αν θα "ανέβει" και στο επόμενο υψηλότερο επίπεδο κ.ο.κ.
Οι λειτουργίες που παρέχει μια skipList είναι: δημιουργία/αρχικοποίηση, εισαγωγή, αναζήτηση, διαγραφή, εκτύπωση της skipList (για λόγους ελέγχου/debugging), διαγραφή/αποδέσμευση ολόκληρης της skipList καθώς και κάποιες λειτουργίες που υλοποιούν κάποιες από τις εντολές που "δίνει" ο χρήστης (εξηγούνται παρακάτω).
Όλες οι επιπλέον λεπτομέρειες σχετικά με την υλοποίηση εξηγούνται αναλυτικά στα σχόλια του κώδικα.


Επιπλέον δομές
---------------
Λίστα χωρών - countryList
--------------------------
Η υλοποίηση της countryList υπάρχει στο αρχείο countryList.c. Είναι μια απλή λίστα η οποία σε κάθε κόμβο περιέχει το όνομα μιας χώρας. Σκοπός της είναι να αποφεύγεται η αποθήκευση του ονόματος μιας χώρας πολλές φορές, δηλαδή η επανάληψη πληροφορίας. Πιο συγκεκριμένα, κάθε φορά που εισάγεται ένας πολίτης στο hash table (δηλαδή στην δομή η οποία αποθηκεύει τα στοιχεία του κάθε πολίτη (citizenId,όνομα,επίθετο,ηλικία,χώρα)) αποθηκεύουμε δείκτη στο όνομα της χώρας που είναι αποθηκευμένο στην countryList. Έτσι όταν έχουμε στην "βάση" μας πολλούς πολίτες από την ίδια χώρα, το όνομα της χώρας αποθηκεύεται μόνο μια φορά στην μνήμη.

Hash Table
-----------
Η υλοποίηση του hash table υπάρχει στο αρχείο hashTable.c. Σκοπός του είναι να μην έχουμε επανάληψη πληροφορίας όσον αφορά τα δεδομένα των πολιτών, αλλά το πρόγραμμα μας να παραμένει αποδοτικό και μη σπάταλο. Πιο συγκεκριμένα, στο hashTable αποθηκεύουμε όλους τους πολίτες για τους οποίους έχουμε τουλάχιστον μία εγγραφή, δηλαδή όλους τους πολίτες οι οποίοι περιέχονται σε τουλάχιστον μια skipList.
To hash Table έχει υλοποιηθεί με λίστα υπερχείλισης.
Επίσης, είναι επεκτατό, δηλαδή το μέγεθος του αυξάνεται δυναμικά όσο τα δεδομένα που εισάγονται σε αυτό αυξάνονται. Έτσι το hashTable παραμένει πάντα αποδοτικό (αναζήτηση/εισαγωγή σε χρόνο Ο(1)) και ταυτόχρονα δεν σπαταλά παραπάνω μνήμη από ότι χρειαζόμαστε.
Ο κατακερματισμός γίνεται με βάση το citizenId. Για κάθε έναν πολίτη, στο hashTable αποθηκεύεται το citizenId, το όνομα, το επίθετο, η ηλικία και η χώρα. Όπως αναφέρθηκε και προηγουμένως, για την χώρα αποθηκεύουμε έναν δείκτη ο οποίος δείχνει στην αντίστοιχη συμβολοσειρά που είναι αποθηκευμένη στην countryList.
Προφανώς, κάθε πολίτης (δηλαδή κάθε citizenId) εισάγεται μόνο μια φορά στο hashTable.
Χρήση του HashTable:
Κάθε φορά πριν από την εισαγωγή ενός πολίτη σε μια skipList ελέγχουμε πρώτα το hashTable. Αν ο πολίτης υπάρχει στο hashTable, τότε μας επιστρέφεται ένας pointer στον κόμβο όπου είναι αποθηκευμένες οι πληροφορίες του. Αν δεν υπάρχει, τότε εισάγεται στο hashTable μας επιστρέφεται ένας pointer στον νέο αυτό κόμβο που εισήχθη ο πολίτης. Έτσι, μπορούμε να εισάγουμε τον πολίτη στην skipList, δίνοντας σαν επιπλέον όρισμα τον pointer αυτόν, έτσι ώστε να αποθηκευτεί στον κόμβο του χαμηλότερου επιπέδου της skipList. Έτσι, όπως έχει αναφερθεί και παραπάνω, στις skipList αποθηκέυονται pointers σε κόμβους του hashTable οι οποίοι περιέχουν της πληροφορίες του αντίστοιχου πολίτη.
Άρα, ανεξαρτήτως το σε πόσες διαφορετικές skipLists έχει εισαχθεί ένας πολίτης, τα δεδομένα του αποθηκεύονται μόνο μία φορά (στο hashTable). Δηλαδή, δεν υπάρχει καθόλου επανάληψη πληροφορίας.
Σε περίπτωση που θέλουμε να εισάγουμε έναν πολίτη στο hashTable, ενώ υπάρχει ήδη κάποιος πολίτης με ίδιο citizenId αλλά διαφορετικά στοιχεία (π.χ. διαφορετικό όνομα) τότε η συνάρτηση εισαγωγής/αναζήτησης επιστρέφει NULL αντί για pointer στον κόμβο. Έτσι, η συνάρτηση που την κάλεσε γνωρίζει ότι η εγγραφή είναι inconsistent ως προς τα δεδομένα και απορρίπτει την εγγραφή (εξηγείται και παρακάτω).


Αρχείο database.c
------------------
Αρχικά στο αρχείο αυτό περιέχεται μια δομή η οποία "συνδυάζει" όλες τις δομές που αναφέρθηκαν παραπάνω έτσι ώστε να δημιουργήσει την δομή που απαιτείται για το πρόγραμμα vaccineMonitor.
Πιο συγκεκριμένα, ορίζεται μια δομή τύπου Data η οποία περιέχει:
- Μια λίστα από ιούς. Κάθε κόμβος της λίστας αυτής αντιστοιχεί σε έναν ιό και περιέχει το όνομα του ιού, ένα bloom filter και δύο skipLists (vaccinated_persons και not_vaccinated_persons).
- Ένα hash table στο οποίο αποθηκεύονται οι πολίτες που εισάγονται στην βάση (για κάποιον ιό) (όπως εξηγήθηκε και παραπάνω)
- Μια countryList η οποία περιέχει όλες της χώρες για της οποίες έχει εισαχθεί τουλάχιστον ένας πολίτης στην βάση και η λειτουργία και ο σκοπός της επίσης εξηγήθηκε παραπάνω.
Έτσι όλα τα δεδομένα μας, αποθηκεύονται εσωτερικά ενός αντικειμένου τύπου Data καθώς και όλες οι λειτουργίες του vaccineMonitor εφαρμόζονται "πάνω" σε ένα αντικείμενο τύπου Data.
Στο αρχείο αυτό υπάρχουν επίσης και οι υλοποιήσεις όλων των λειτουργιών του vaccineMonitor που ζητούνται στην εκφώνηση.
Όλες οι λειτουργίες χρησιμοποιούν συναρτήσεις που παρέχονται από τις δομές που εξηγήθηκαν παραπάνω, επομένως κάποιες από αυτές είναι αρκετά trivial. Σε κάθε περίπτωση εξηγούνται αναλυτικά στα σχόλια του κώδικα και θα περιγραφούν συνοπτικά παρακάτω.

Εισαγωγή εγγραφών από το αρχείο:
Η συνάρτηση readCitizenRecordsFile είναι υπεύθυνη για την ανάγνωση του αρχείου. Διαβάζει μια προς μία τις γραμμές/εγγραφές του αρχείου και αφού κάνει το απαραίτητο error checking καλεί την συνάρτηση insertFromFile έτσι ώστε να γίνει η εισαγωγή. Η insertFromFile εντοπίζει τον κόμβο του ιού (από την virusList) για τον ιό στον οποίο αναφέρεται η εγγραφή, ελέγχει αν η εγγραφή είναι consistent ή inconsistent και αν είναι consintent την εισάγει στο bloomFilter και στην vaccinated_persons skipList (αν η εγγραφή περιέχει YES) ή μόνο στην not_vaccinated_persons (αν η εγγραφή περιέχει ΝΟ). Πριν από κάθε εισαγωγή γίνεται αναζήτηση/εισαγωγή του πολίτη στο hashTable (όπως έχει ήδη αναφερθει). Μια εγγραφή θεωρείται inconsistent (για την εισαγωγή από το αρχείο) αν έχει εισαχθεί μια εγγραφή για τον ίδιο πολίτη και τον ίδιο ιό (ανεξαρτήτως αν περιέχουν YES ή NO). Σε κάθε περίπτωση λανθασμένης εγγραφής εκτυπώνεται το αντίστοιχο μήνυμα λάθους.


/vaccineStatusBloom:
- - - - - - - - - - -
Εντοπίζεται ο αντίστοιχος κόμβος της virusList και καλείται η συνάρτηση bloomExists για το bloomFilter του ιού αυτού η οποία και εκτυπώνει το αποτέλεσμα. Αν δεν υπάρχει ο ιός στην βάση μας (δηλαδή δεν βρεθεί ο αντίστοιχος κόμβος της virsuList) τότε εκτυπώνεται NOT VACCINATED αφού δεν έχουμε καμία εγγραφή για τον ιό αυτό.

/vaccineStatus:
- Εάν έχει δοθεί ιός τότε καλείται η συνάρτηση vaccineStatus. Βρίσκει τον αντίστοιχο κόμβος της virusList του δοθέντα ιού και ελέγχει εάν ο πολίτης με το δοθέν citizenId υπάρχει στην vaccinated_persons skipList του ιού αυτού. Η συνάρτηση αναζήτησης (searchGetDateSL) αν βρεί τον πολίτη, επιστρέφει την ημερομηνία στην οποία εμβολιάστηκε, αλλιώς επιστρέφει NULL. Αν βρεθεί, εκτυπώνεται VACCINATED ON: ακολουθούμενο από την ημερομηνία εμβολιασμού, αλλιώς εκτυπώνεται NOT VACCINATED.
- Εάν δεν έχει δοθεί ιός τότε καλείται η συνάρτηση vaccineStatusAll. Για κάθε έναν ιό της virusList, αρχικά ελέγχει την vaccinated_persons του κάθε ιού. Αν υπάρχει ο πολίτης εκτυπώνει την ημερομηνία εμβολιασμού (ομοίως με παραπάνω). Αν δεν βρεθεί, ελέγχει την not_vaccinated_persons. Αν βρεθεί στην not_vaccinated_persons εκτυπώνει το όνομα του ιού ακολουθούμενο από ΝΟ καθώς είναι καταχωρημένος σαν μη εμβολιασμένος. Σε περίπτωση που δεν υπάρχει σε καμία από τις 2 skipList, δεν εκτυπώνεται τίποτα και συνεχίζει με τον επόμενο ιό της virusList.

/insertCitizenRecord
- - - - - - - - - - -
Εντοπίζεται ο κόμβος της virusList του ιού που αφορά η εγγραφή. Αν δεν υπάρχει, δημιουργείται (δηλαδή δημιουργούνται/αρχικοποιούνται και οι αντίστοιχες δομές bloomFilter και skipLists). Στην συνέχεια ελέγχουμε το hashTable για το αν υπάρχει ο πολίτης, αν δεν υπάρχει εισάγεται και σε κάθε περίπτωση μας επιστρέφεται δείκτης στην εγγραφή του πολίτη. Αν ο πολίτης υπάρχει, αλλά με διαφορετικά στοιχεία τότε επιστρέφεται NULL, εκτυπώνεται μήνυμα λάθους και η εισαγωγή τερματίζεται.
Αν η εγγραφή περιέχει YES στο πεδίο vaccinated τότε διαγράφουμε τον πολίτη από την not_vaccinated_persons (εάν υπάρχει) και τον εισάγουμε στο bloomFilter και στην vaccinated_persons skipList. Αν ο πολίτης υπάρχει ήδη στην vaccinated_persons skipList του ιού αυτού τότε (προφανώς δεν ξαναγίνεται η εισαγωγή) και εκτυπώνεται μήνυμα λάθος καθώς και η ημερομηνία του "προηγούμενου" εμβολιασμού.
Αν η εγγραφή περιέχει NO στο πεδίο vaccinated τότε αρχικά ελέγχουμε αν ο πολίτης υπάρχει στην vaccinated_persons skipList. Αν υπάρχει εκτυπώνεται μήνυμα λάθους και η ημερομηνία εμβολιασμού. Αν δεν υπάρχει τότε εισάγεται στην not_vaccinated_persons skipList. Αν υπάρχει ήδη στην not_vaccinated_persons skipList τότε εκτυπώνεται μήνυμα λάθους.

/vaccinateNow
- - - - - - - - - - -
Η υλοποίηση είναι ίδια με αυτήν της insertCitizenRecord θεωρόντας πως στο πεδίο vaccinated έχει δοθεί YES. Δηλαδή δεν δίνεται σαν όρισμα το πεδίο vaccinated και δεν γίνεται ο διαχωρισμός για το αν η εγγραφή περιέχει YES ή NO. Η διαφορά είναι ότι αντί να έχουμε σαν όρισμα την ημερομηνία εμβολιασμού, παίρνουμε την τρέχουσα ημερομηνία μέσω της συνάρτησης localtime.

/listNonVaccinatedPersons
- - - - - - - - - - -
Εντοπίζεται ο κόμβος της virusList του ιού που δόθηκε και εκτυπώνονται όλες οι εγγραφές που υπάρχουν στην not_vaccinated_persons skipList του ιού αυτού μέσω της συνάρτησης listPersons (skipList.c). H listPersons ουσιαστικά διατρέχει τους κόμβους της λίστας του χαμηλότερου επιπέδου της skipList (δηλαδή όλα τα κλειδιά που έχουν εισαχθεί σε αυτήν) και για κάθε ένα εκτυπώνει να δεδομένα που αντιστοιχούν στον πολίτη με αυτό το id μέσω του δείκτη στην εγγραφή που υπάρχει στους κόμβους του επιπέδου 1.

/populationStatus
- - - - - - - - - - -
Θεωρώ τα dates ως προαιρετικά (όπως αναφέρθηκε στο piazza), άρα τα ποσοστά που υπολογίζονται προκύπτουν ως έξης:
- Αν έχουν δοθεί τα dates: (#vaccinated for country inside [date1,date2] for the given virus)/(#vacinated + #not_vaccinated for country for the given virus)
- Αν δεν έχουν δοθεί τα dates: (#vaccinated for country for the given virus)/(#vacinated + #not_vaccinated for country for the given virus)
Για την εύρεση των ποσοστών που αφορούν τον ιό που δόθηκε χρησιμοποιείται μια λίστα τύπου countryCounterList η οποία υλοποιείται στο αρχείο countryLists.c και έχει υλοποιηθεί αποκλειστικά για το ερώτημα αυτό. Κάθε κόμβος της λίστας αντιστοιχεί σε μία χώρα και περιέχει: το όνομα της χώρας, έναν μετρητή όπου μετράει το πόσοι πολίτες πληρούν τις επιθυμητές προϋποθέσεις (meetsConditionsCount) και έναν συνολικό μετρητή των καταγεγραμμένων πολιτών στον συγκεκριμένο ιό (totalCounter).
meetsConditionsCount: Αν έχουν δοθεί τα date1 και date2 τότε ο μετρητής αυτός περιέχει τους πολίτες (της χώρας που αντιστοιχεί ο κάθε κόμβος) οι οποίοι έχουν εμβολιαστεί για τον δοθέντα ιό μέσα στο διάστημα [date1,date2]. Αν δεν έχουν δοθεί τα dates τότε ο μετρητής meetsConditionsCount περιέχει τον αριθμό εμβολιασμένων της κάθε χώρας ανεξαρτήτως της ημερομηνίας εμβολιασμού.
totalCounter: Περιέχει τον αριθμό των καταγεγραμμένων πολιτών της κάθε χώρας σχετικά με τον δοθέντα ιό, δηλαδή το σύνολο των πολιτών από την κάθε χώρα που υπάρχουν στις vaccinated_persons και not_vaccinated_persons.
Άρα τελικά το επιθυμητό ποσοστό προκύπτει από το κλάσμα  (meetsConditionsCount/totalCounter)*100.
Οι μετρητές αυτοί αυξάνονται κατάλληλα μέσω της συνάρτησης populationStatusSL (του αρχείου skipList.c). Έτσι καλούμε την συνάρτηση και για τις δύο skipList δίνοντας σαν όρισμα την λίστα τύπου countryCounterList. Τελικά, έπειτα από τις δύο κλήσεις, έχουν αυξηθεί κατάλληλα οι μετρητές για κάθε χώρα και το μόνο που απομένει είναι να εκτυπώσουμε τον μετρητή και το ποσοστό της κάθε χώρας/κόμβου της λίστας.
Σε περίπτωση που έχει δοθεί και η χώρα από τον χρήστη τότε η λίστα τελικά περιέχει μόνο έναν κόμβο ο οποίος αντιστοιχεί στην χώρα αυτήν.
Περισσότερες λεπτομέρειες εξηγούνται αναλυτικά στα σχόλια του κώδικα.

/popStatusByAge
- - - - - - - - - - -
Ομοίως θεωρώ τα dates ως προαιρετικά, άρα τα ποσοστά που υπολογίζονται προκύπτουν ως έξης:
- Αν έχουν δοθεί τα dates: (#vaccinated for country inside [date1,date2] for the given virus with age<20)/(#vacinated + #not_vaccinated for country for the given virusage<20)
	(ομοίως και για τις κατηγορίες 20<=virusage<40 , 0<=virusage<60 και virusage<=60 )
- Αν δεν έχουν δοθεί τα dates: (#vaccinated for country for the given virus with age<20)/(#vacinated + #not_vaccinated for country for the given virus with age<20)
	(ομοίως και για τις υπόλοιπες κατηγορίες)
Η υλοποίηση είναι παρόμοια με αυτήν της /populationStatus με την διαφορά ότι χρησιμοποιείται μια λίστα τύπου countryAgeList της οποίας η υλοποίηση επίσης υπάρχει στο αρχείο countryLists.c. Η λογική είναι ακριβώς η ίδια με αυτήν της countryCounterList με μόνη διαφορά ότι αντί να έχουμε έναν meetsConditionsCount 4 διαφορετικούς μετρητές ανάλογα με την ηλικία και επίσης τον συνολικό μετρητή total counter. Έτσι κάθε φορά που ένας πολίτης "πληροί τις προϋποθέσεις" αυξάνουμε τον αντίστοιχο από τους 4 μετρητές ανάλογα με την ηλικία του. Η δεύτερη διαφορά είναι ότι καλείται η συνάρτηση popStatusByAgeSL (αντί της populationStatusSL) για κάθε μια από τις skipLists η οποία όμως εκτελεί πολύ παρόμοια λειτουργία. Κατά τα άλλα η υλοποίηση είναι ίδια με αυτήν που εξηγήθηκε παραπάνω.

ΠΑΡΑΤΗΡΗΣΗ: Έχω επιλέξει να δημιουργώ αυτές τις δομές κάθε φορά που καλείται ένα από τα ερωτήματα /populationStatus και /popStatusByAge και να διατρέχω τις 2 skipList του δοθέντα ιού. Διαφορετικά, θα μπορούσα να κρατάω μονίμως κάποια επιπλέον δομή η οποία να περιέχει για κάθε ιό τις πληροφορίες αυτές. Ωστόσο μια τέτοια υλοποίηση θα ήταν αρκετά σπάταλη καθώς θα είχε μονίμως δεσμευμένο πολύ χώρο για κάποιες εντολές οι οποίες καλούνται πολύ σπάνια ή μπορεί να μην εκτελεστούν και ποτέ. Άρα ίσως η υλοποίηση μου να μην είναι και η γρηγορότερη (για τεράστιο! όγκο δεδομένων) ωστόσο δεν είναι καθόλου σπάταλη όσο αναφορά την μνήμη που δεσμεύει. Έτσι κατά την γνώμη μου, αυτή η υλοποίηση έχει περισσότερα πλεονεκτήματα.


Αρχείο main.c
------------------
Στο αρχείο αυτό υπάρχει η υλοποίηση της συνάρτησης main. Αρχικά διαβάζονται τα ορίσματα που δόθηκαν από τον χρήση κατά την εκτέλεση του προγράμματος. Σε περίπτωση λάθους εκτυπώνεται το αντίστοιχο μήνυμα και η εκτέλεση σταματά.
Στην συνέχεια δημιουργείται και αρχικοποιείται ένα αντικείμενο τύπου Data το οποίο θα περιέχει όλα τα δεδομένα και τις δομές του προγράμματος. Έπειτα καλείται η συνάρτηση readCitizenRecordsFile έτσι ώστε να διαβαστούν και να εισαχθούν οι εγγραφές από το αρχείο εισόδου που δόθηκε από την χρήστη.
Μετά την εισαγωγή από το αρχείο, μέσω μιας επαναληπτικής διαδικασίας διαβάζονται οι εντολές από τον χρήστη. Μέσω if statements "εντοπίζεται" το ποια εντολή θέλει να εκτελέσει ο χρήσης, γίνεται το απαραίτητo error checking και στην συνέχεια καλείται η αντίστοιχη συνάρτηση του αρχείου database.c η οποία εκτελεί την αντίστοιχη λειτουργία. Σε κάθε περίπτωση λάθους εκτυπώνεται το αντίστοιχο μήνυμα και το πρόγραμμα περιμένει την επόμενη εντολή από τον χρήστη. Η διαδικασία αυτή σταματά όταν δοθεί η "εντολή" exit από τον χρήστη. Όταν γίνει αυτό, αποδεσμεύεται κατάλληλα όλη η μνήμη που έχει δεσμευτεί (για το αντικείμενο τύπου Data) και η εκτέλεση τερματίζεται.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Bash Script
------------
Όλα τα αρχεία σχετικά με το Bash Script υπάρχουν στο directory με όνομα BashScript.
Το αρχείο testFile.sh περιέχει το script, δηλαδή είναι το αρχείο το οποίο εκτελούμε.
Τα αρχεία virusesFile.txt και countriesFile.txt περιέχουν διάφορους ιούς και χώρες αντίστοιχα και είναι τα αρχεία τα οποία δίνονται σαν είσοδος στο script.
Το αρχείο με τις εγγραφές που παράγεται έχει όνομα inputFile.
Η διαδικασία που ακολουθείται είναι: 
Αρχικά γίνεται το απαραίτητο error checking όσον αφορά τα ορίσματα που δόθηκαν. Σε περίπτωση λάθους εκτυπώνεται το αντίστοιχο μήνυμα και ο εκτέλεση ολοκληρώνεται. Αν στο πεδίο duplicatesAllowed δοθεί οτιδήποτε άλλο εκτός από 0 θεωρούμε ότι duplicatesAllowed=1.
Διαβάζεται το αρχείο με τις χώρες και αποθηκεύονται όλες οι χώρες σε ένα array. Ομοίως και το για το αρχείο με τους ιούς.
Δημιουργώ έναν πίνακα μεγέθους numLines ο οποίος περιέχει τυχαίους μοναδικούς αριθμούς στο διάστημα 0-9999 (αφού το id μπορεί να περιέχει το πολύ 4 χαρακτήρες).
Ξεκινώντας από την πρώτη θέση του πίνακα, κάθε φορά που θέλω να δημιουργήσω μια νέα εγγραφή με μοναδικό id παίρνω αυτό το id τρέχουσα θέση του πίνακα. Στην επόμενη μοναδική εγγραφή συνεχίζω με την αμέσως επόμενη θέση του πίνακα, για να πάρω ένα νέο μοναδικό id.
O πίνακας είναι μεγέθους numLines καθώς στην χειρότερη περίπτωση θα χρειαστώ numLines διαφορετικά id (δηλαδή στην περίπτωση όπου duplicatesAllowed=0).
Για να δημιουργηθεί ολοκληρωθεί η μοναδική εγγραφή παράγονται 2 τυχαίες συμβολοσειρές για τα firstName και lastName καθώς και ένας τυχαίος αριθμός για την ηλικία. Επίσης, επιλέγεται μια τυχαία χώρα και ένας τυχαίος ιός από τον πίνακα χωρών και τον πίνακα ιών αντίστοιχα. Επιλέγεται τυχαία το αν η εγγραφή θα περιέχει YES ή NO και αν περιέχει YES, δημιουργείται μια τυχαία ημερομηνία. Τελικά, "ενώνονται" όλες οι παραπάνω συμβολοσειρές και παράγεται η εγγραφή η οποία και γράφεται στο αρχείο inputFile.
Σε περίπτωση που το duplicatesAllowed είναι 1, τότε επιλέγεται τυχαία για το αν θα δημιουργηθεί duplicate εγγραφή για το συγκεκριμένο id. Αν δημιουργηθεί, τότε κρατάμε το id καθώς τα firstName, lastName, country, age που δημιουργήθηκαν προηγουμένως έτσι ώστε η εγγραφή να είναι consistent όσον αφορά τα δεδομένα αυτά. Δημιουργούνται τυχαία τα υπόλοιπα στοιχεία και έτσι παράγεται η νέα duplicate εγγραφή. Η διαδικασία παραγωγής των duplicate εγγραφών είναι επαναληπτική έτσι ώστε να μπορούν να παραχθούν πολλαπλά duplicate records για ένα id. Η πιθανότητα παραγωγής duplicate εγγραφών (για το ίδιο id) μειώνεται σταδιακά όσο δημιουργούνται duplicates για το ίδιο id.
Περισσότερες λεπτομέρειες εξηγούνται στα σχόλια του κώδικα.
Special cases:
- Αν duplicatesAllowed=0 και ζητούνται παραπάνω από 10.000 εγγραφές τότε παράγεται το μέγιστο πλήθος μοναδικών εγγραφών που μπορούν να παραχθούν με id μήκους 4. Δηλαδή παράγονται 10.000 εγγραφές με μοναδικά id (από 0 μέχρι 9999 σε τυχαία σειρά), στην συνέχεια εκτυπώνεται αντίστοιχο μήνυμα λάθους και το πρόγραμμα τερματίζει.
- Αν duplicatesAllowed=1 και ζητούνται παραπάνω από 10.000 εγγραφές τότε παράγεται κανονικά ο ζητούμενος αριθμός εγγραφών. 

